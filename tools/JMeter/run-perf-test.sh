#!/bin/sh
# Run performance test. Return 0 if the SLA was met, non-zero otherwise.
# Starts a set of slave nodes, deploys test suite to each, and runs perf test.
# It is assumed that the slaves have already been created via the tools
# script JMeter/deploy.sh.
# This can be run from any machine, e.g., the Jenkins machine, as this script
# has a small compute footprint: load is generated by the slave machines.
# EC2 command line tools must be installed on this machine.
# Parameters:
#	NoOfSlaves
#	RMIRegistryPort - This port must be open on each machine.
#	JMeterSlavePort - This port must be open on each slave machine.
#	JMeterControllerCallbackPort - This port must be open on the client (this) machine.
#	PerfPlanFilePath - The JMeter test plan (.jmx) file.
#	SlaveInstanceIdFilePath - File that contains a comma-separated list of EC2 instance
#		ids, created by tools/JMeter/deploy.sh.
#	LeaveSlavesRunning - If specified, the slaves are not stopped before exiting.
# Env variables that must be set prior to running this script:
#	AWS_REGION, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, EC2_LOCAL_PEM_FILE_PATH
# Ref: https://jmeter.apache.org/usermanual/remote-test.html
# Ref: http://www.tutorialspoint.com/jmeter/index.htm

# Check if parameters have been specified.
if [ -z $6 ]
then
	echo "JMeter/run-perf-test.sh: Usage: ./JMeter/run-perf-test.sh <nunber-of-slaves> <RMI-registry-port> <slave-server-port> <controller-callback-port> <perf-plan> <slave-instance-id-file> [ <leave-slaves-running> ]"
	exit 2
fi

NoOfSlaves=$1
RMIRegistryPort=$2
JMeterSlavePort=$3
JMeterControllerCallbackPort=$4
PerfPlanFilePath=$5
SlaveInstanceIdFilePath=$6
LeaveSlavesRunning=$7

echo "Make sure that slaves can receive calls on port $JMeterSlavePort, and this server can receive calls on $JMeterControllerCallbackPort"

# Check if requried env variables have been set.
if [ -z $AWS_REGION ]; then
	echo "JMeter/run-perf-test.sh: env variable AWS_REGION not set."
	exit 2
fi

if [ -z $AWS_ACCESS_KEY_ID ]; then
	echo "JMeter/run-perf-test.sh: env variable AWS_ACCESS_KEY_ID not set."
	exit 2
fi

if [ -z $AWS_SECRET_ACCESS_KEY ]; then
	echo "JMeter/run-perf-test.sh: env variable AWS_SECRET_ACCESS_KEY not set."
	exit 2
fi

if [ -z $EC2_LOCAL_PEM_FILE_PATH ]; then
	echo "JMeter/run-perf-test.sh: env variable EC2_LOCAL_PEM_FILE_PATH not set."
	exit 2
fi

# Get this script directory's path.
pushd $( dirname "${BASH_SOURCE[0]}" )
export ThisDir=`pwd`
echo "JMeter/run-perf-test.sh: ThisDir=$ThisDir"
popd

# Get IP address of this machine.
ControllerIPAddr=`ip addr | grep 'state UP' -A2 | grep "inet " | grep eth | awk '{print $2}' | cut -f1 -d'/'`
echo "Controller IP address: $ControllerIPAddr"

# Set constants.
TestResultsDir=$ThisDir/test_results
JMeterLogFile=jmeter.log
JMeterStdout=jmeter.stdouterr.log
EC2UserId=ec2-user
JMETER_HOME=/usr/local/apache-jmeter-3.0
MaxSlaveBootTimeoutSeconds=120
ResultsFile=results.csv

# Obtain instance Ids of slave machines.
# The file at $SlaveInstanceIdFilePath contains a comma-separated list
# of EC2 instance Ids.
echo "Obtaining slave Ids from $SlaveInstanceIdFilePath..."
if [ ! -f $SlaveInstanceIdFilePath ]; then
	echo "JMeter/run-perf-test.sh: File containing slave instance Ids not found - did you run tools/JMeter/deploy.sh?"
	exit 2
fi
AvailSlaveIdsComSep=`cat $SlaveInstanceIdFilePath`
Status=$?
if [ $Status -ne 0 ]; then
	echo "JMeter/run-perf-test.sh: Error reading slave instance Id file"
	exit $Status
fi
echo "Slave Ids: $AvailSlaveIdsComSep"

# Construct an array of available slave instance Ids.
AvailSlaveIdsSpaceSep="${AvailSlaveIdsComSep//,/ }"
# Replaces all occurrences of ',' (the initial // means global replace) in the variable
# with ' ' (a single space), then interprets the space-delimited string as an array
# (that's what the surrounding parentheses do).
Status=$?
if [ $Status -ne 0 ]; then
	echo "JMeter/run-perf-test.sh: Error parsing instance Ids: $AvailSlaveIdsComSep"
	exit $Status
fi
echo "AvailSlaveIdsSpaceSep=$AvailSlaveIdsSpaceSep"

# Check that we have enough slaves available.
echo "Check we have enough slaves..."
NoOfSlavesAvail=0
for slaveId in $AvailSlaveIdsSpaceSep; do
	let NoOfSlavesAvail+=1
done
if [ $NoOfSlaves -gt $NoOfSlavesAvail ]; then
	echo "JMeter/run-perf-test.sh: Too many slaves ($NoOfSlaves) - we only have $NoOfSlavesAvail"
	exit 2
fi

# Create list of the instance Ids of the slaves to be started.
echo "Creating list of instances to start..."
InstanceIdsForEC2=""
InstanceIdsForJMeter=""
EC2Separator=""
JMeterSeparator=""
i=0
echo "AvailSlaveIdsSpaceSep=$AvailSlaveIdsSpaceSep"
for slaveId in $AvailSlaveIdsSpaceSep; do
	let i+=1
	if [ $i -gt $NoOfSlaves ]; then break; fi
	echo "i=$i"
	InstanceIdsForEC2="${InstanceIdsForEC2}${EC2Separator}${slaveId}"
	InstanceIdsForJMeter="${InstanceIdsForJMeter}${JMeterSeparator}${slaveId}"
	EC2Separator=" "
	JMeterSeparator=","
done
echo "Instances to be used: $InstanceIdsForEC2"

# Start slaves - but only the ones that are not already running.
echo "Starting slaves..."
for instid in $InstanceIdsForEC2; do
	Status=`/usr/local/bin/aws --query 'InstanceStatuses[0].InstanceState.Name' --output text \
		ec2 describe-instance-status --instance-ids $instid`
	if [ "$Status" == "running" ]; then
		echo "Slave instance $instid is already running."
	else
		echo "Starting slave instance $instid..."
		/usr/local/bin/aws ec2 start-instances --instance-ids $instid
		# (Slave image must include a disabled firewall.)
		# Ref: http://docs.aws.amazon.com/AWSEC2/latest/CommandLineReference/ec2-clt.pdf
	fi
done

# Wait for all slaves to boot.
# Ref: http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstanceStatus.html
echo "Waiting for slaves to boot..."
DeltaT=10
for instid in $InstanceIdsForEC2; do
	T=0
	Timeout=$MaxSlaveBootTimeoutSeconds
	Status=""
	echo "...waiting up to $MaxSlaveBootTimeoutSeconds seconds for instance $instid..."
	while [ "$Status" != "running" ]; do
		# Note: This command will only work within the same VPC as the target instances.
		Status=`/usr/local/bin/aws --query 'InstanceStatuses[0].InstanceState.Name' --output text \
			ec2 describe-instance-status --instance-ids $instid`
		let T=T+$DeltaT
		if [ $T -gt $Timeout ]; then
			echo "Timeout waiting for instance $instid to boot"
			exit 2
		fi
		printf "."
		sleep $DeltaT
	done
	printf "\n"
done
echo "...all slaves started."

# Prepare each slave.
# Ref: http://stackoverflow.com/questions/16618915/setting-up-jmeter-for-distributed-testing-in-aws-with-connectivity-issues
SlaveIpsCommaSep=""
separator=""
nIps=0
for instanceId in $InstanceIdsForEC2; do
	let nIps+=1
	
	# Get slave internal (subnet) IP address.
	SlavePrivateIpAddr=`/usr/local/bin/aws ec2 describe-instances --instance-ids $instanceId \
		--output=text \
		--query "Reservations[*].Instances[*].PrivateIpAddress"`
	Status=$?
	if [ $Status -ne 0 ]; then
		echo "JMeter/run-perf-test.sh: Error obtaining private IP address of instance $instanceId"
		exit $Status
	fi
	echo "Slave $nIps has private IP address $SlavePrivateIpAddr"
	SlaveIpsCommaSep=$SlaveIpsCommaSep$separator$SlavePrivateIpAddr
	separator=","

	# Get slave public IP address.
	SlavePublicIpAddr=`/usr/local/bin/aws ec2 describe-instances --instance-ids $instanceId \
		--output=text \
		--query "Reservations[*].Instances[*].PublicIpAddress"`
	Status=$?
	if [ $Status -ne 0 ]; then
		echo "JMeter/run-perf-test.sh: Error obtaining public IP address of instance $instanceId"
		exit $Status
	fi
	echo "Slave $nIps has public IP address $SlavePublicIpAddr"
	
	# Deploy test suite to each slave.
	#echo "Deploying test suite to $SlavePrivateIpAddr..."
	#ssh -i $EC2_LOCAL_PEM_FILE_PATH -o StrictHostKeyChecking=no \
	#	$EC2UserId@$SlavePrivateIpAddr "git clone ..."
	
	# Determine if jmeter is already running on the node, and start jmeter if not.
	psEntry=`ps -A | grep jmeter`
	if grep -q jmeter <<<$psEntry; then
		echo "JMeter is already running on slave $instanceId"
	else
		echo "Starting jmeter on $SlavePrivateIpAddr..."
		ssh -i $EC2_LOCAL_PEM_FILE_PATH -o StrictHostKeyChecking=no $EC2UserId@$SlavePrivateIpAddr \
			"nohup java -jar $JMETER_HOME/bin/ApacheJMeter.jar -s -n -Djava.rmi.server.hostname=$SlavePrivateIpAddr -Dserver.rmi.localport=$JMeterSlavePort -Dclient.rmi.localport=$JMeterControllerCallbackPort &> $JMeterStdout < /dev/null &"
	fi
done
echo "Started $nIps slaves on these IP addresses: $SlaveIpsCommaSep"

# Initiate tests from controller.
mkdir $TestResultsDir
echo "JMETER_HOME=$JMETER_HOME"
echo "PerfPlanFilePath=$PerfPlanFilePath"
echo "ControllerIPAddr=$ControllerIPAddr"
echo "JMeterControllerCallbackPort=$JMeterControllerCallbackPort"
echo "JMeterSlavePort=$JMeterSlavePort"
echo "SlaveIpsCommaSep=$SlaveIpsCommaSep"
echo "ResultsFile=$ResultsFile"
echo "JMeterStdout=$JMeterStdout"
echo "Starting tests for test plan at $PerfPlanFilePath..."
rm -f $ResultsFile
java -version
ls $JMETER_HOME
java -jar "$JMETER_HOME/bin/ApacheJMeter.jar" -n \
	-t "$PerfPlanFilePath" \
	-Djava.rmi.server.hostname=$ControllerIPAddr \
	-Dclient.rmi.localport=$JMeterControllerCallbackPort \
	-R$SlaveIpsCommaSep \
	-l$ResultsFile
	#-Dsummariser.log=false \
	#-o $TestResultsDir \
	#-e -l $JMeterLogFile \
echo "...tests completed."

status=$?
if [ $status -ne 0 ]; then
	echo "Warning: JMeter exited with status $status"
fi

# Stop all slaves if necessary.
if [ -z $LeaveSlavesRunning ]; then
	echo "Stopping all slaves..."
	/usr/local/bin/aws ec2 stop-instances --instance-ids $InstanceIdsForEC2 --force
fi

# Determine if test passed.
# Parse the summary report file.
# Ref: https://jmeter.apache.org/usermanual/component_reference.html#Summary_Report
#....assert that average elapsed < ...
# assert that average Latency < ...


